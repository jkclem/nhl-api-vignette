---
title: "NHL API Vignette"
author: "John Clements"
date: "6/15/2021"
output: 
  html_document:
    toc: true
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Requirements

To use the functions for interacting with the [NHL API](https://gitlab.com/dword4/nhlapi/-/blob/master/records-api.md), you need to install and load:

- [`tidyverse`](https://www.tidyverse.org/): tons of useful features for data manipulation and plotting
- [`jsonlite`](https://cran.r-project.org/web/packages/jsonlite/): API interaction

Additionally, I used the following packages for the data exploration:

- [`cowplot`](https://cran.r-project.org/web/packages/cowplot/index.html): extra functionality for `ggplot2`
- [`imager`](https://cran.r-project.org/web/packages/imager/): loading in an images
- [`knitr`](https://cran.r-project.org/web/packages/knitr/index.html): displaying tables and dataframes
- [`broom`](https://cran.r-project.org/web/packages/broom/vignettes/broom.html):
I used it for tidying up a regression output

I didn't pull in the entire  to avoid pulling in unnecessary functions.

```{r warning=FALSE, message=FALSE}
library(tidyverse)
library(jsonlite)
library(cowplot)
library(imager)
library(broom)
```

# Functions

## `convertToNumeric`

I made this helper function to convert columns that contain numeric data stored as `character` values to numeric data types. I ran into an issue where my calls from the API were returning some numeric data as `character` data and needed a way to deal with this issue without just calling `as.numeric` as needed.

```{r}
convertToNumeric <- function(vec){
  ###
  # This function will convert the input vector to a numeric vector if it is 
  # able to. Otherwise, it just returns the vector.
  ###
  
  # If any of the values in vec return NA when trying to convert to numeric,
  # just return vec as the output.
  if (any(is.na(suppressWarnings(as.numeric(vec))) == TRUE)){
    output <- vec
  }
  # Otherwise, convert vec to a numeric vector.
  else {
    output <- as.numeric(vec)
  }
  return(output)
}
```

## `franchise`

I wrote this function to interact with the `franchise` endpoint of the [NHL Records API](https://gitlab.com/dword4/nhlapi/-/blob/master/records-api.md). It returns a `data.frame` containing the franchise and current team Id numbers, the name and abbreviations of teams, and their first and last seasons. It takes one argument; `team`, which can either be `"all"`, the full name of a team (e.g. `"New Jersey Devils"`), or the most recent team Id (e.g. `1` for the New Jersey Devils).

```{r}
franchise <- function(team="all"){
  ###
  # This functions returns a dataframe with metadata on all teams who ever 
  # played in the NHL. It can also return those columns for a single team if a 
  # franchise ID or name is passed.
  ###
  
  # Get the franchise data from the franchises endpoint.
  outputAPI <- fromJSON(
      "https://records.nhl.com/site/api/franchise"
      )
  
  # Select only the dataframe.
  output <- outputAPI$data
  
  # If team does not equal "all", check if it is a franchise ID or team name.
  if (team != "all"){
    
    # If team is in the id column, subset output for just that row.
    if (team %in% output$id){
      output <- output %>%
        filter(mostRecentTeamId == team)
    }
    # If team is in the fullName column, subset output for just that row.
    else if (team %in% output$fullName){
      output <- output %>%
        filter(fullName == team)
    }
    # Otherwise, warn the user and return the entire dataframe.
    else {
      message <- paste("ERROR: Argument for team was not found in either",
                       "the fullName or id columns. Try franchise('all') to",
                       "find the team you're looking for.")
      stop(message)
    }
  }
  # Do nothing if the team value equals "all".
  else {
    
  }
  
  # Convert any columns that should be numeric to numeric.
  output <- suppressMessages(as.data.frame(lapply(output, convertToNumeric)))
  
  # Return the output dataframe.
  return(output)
}
```

## `teamTotals`

I wrote this function to interact with the `franchise-team-totals` endpoint of the NHL Records API. It returns a large number of statistics for the entire history of a team for both regular season and playoff games. It takes one argument; `team`, which can either be `"all"`, the full name of a team (e.g. `"New Jersey Devils"`), or the most recent team Id (e.g. `1` for the New Jersey Devils).

```{r}
teamTotals <- function(team="all"){
  ###
  # This function returns total stats for every franchise (ex roadTies,
  # roadWins, etc) unless a specific team Id or full team name is passed.
  ###
  
  # Get the franchise data from the franchises endpoint.
  outputAPI <- fromJSON(
    "https://records.nhl.com/site/api/franchise-team-totals"
    )
  
  # Select only the dataframe.
  output <- outputAPI$data
  
  # If team does not equal "all", check if it is a team ID or team name.
  if (team != "all"){
    
    # If team is in the franchiseId column, subset output for just that row.
    if (team %in% output$teamId){
      output <- output %>%
        filter(teamId == team)
    }
    # If team is in the teamName column, subset output for just that row.
    else if (team %in% output$teamName){
      output <- output %>%
        filter(teamName == team)
    }
    # Otherwise, warn the user and return the entire dataframe.
    else {
      message <- paste("WARNING: Argument for team was not found in either",
                       "the teamName or franchiseId columns. Returning all",
                       "franchises.")
      warning(message)
    }
  }
  # Do nothing if the team value equals "all".
  else {
    
  }
  
  # Convert any columns that should be numeric to numeric.
  output <- suppressMessages(as.data.frame(lapply(output, convertToNumeric)))
  
  # Return the output dataframe.
  return(output)
}
```

## `findTeamId`

This is a helper function to look up the most recent team Id for a full team name (e.g. `"Boston Bruins"`) because I a didn't feel like hard coding it. It is used in the `franchiseDetail` and `seasonStats` functions because the endpoints they connect to use the most recent team Id to access team-level data in the API call.

```{r}
findTeamId <- function(teamName){
  ###
  # This helper function looks up the franchise id for a full team name 
  # e.g. "Boston Bruins".
  ###
  
  # Call the franchise function with the team name.
  teamId <- franchise(teamName)
  
  # Return only the most recent team id number.
  return(teamId$mostRecentTeamId)
}
```

## `findFranchiseId`

This is a helper function does the same thing as `findTeamId`, except for the franchise Id. It is used in the `seasonRecords`, `goalieRecords`, and `skaterRecords` functions because they use the franchise Id to access team-level data in the API call.

```{r}
findFranchiseId <- function(teamName){
  ###
  # This helper function looks up the franchise id for a full team name 
  # e.g. "Boston Bruins".
  ###
  
  # Call the franchise function with the team name.
  teamId <- franchise(teamName)
  
  # Return only the most recent team id number.
  return(teamId$id)
}
```

## `seasonRecords`

The `seasonRecords` function returns the records stats for a single team. For example, the most goals scored in a season and the season they scored it in. It takes one argument; `team`, which can either be the full name of a team (e.g. `"New Jersey Devils"`), or the **franchise Id** (e.g. `23` for the New Jersey Devils).

```{r}
seasonRecords <- function(team){
  ###
  # This functions returns a dataframe with the season records for a variety 
  # of stats for a single team.
  ###
  
  # If team is a "character" type, try to look up the team id.
  if (typeof(team) == "character"){
    teamId = findFranchiseId(team)
  }
  # If team is an integer, set teamId equal to team.
  else if ((typeof(team) == "double") & (team %% 1 == 0)){
    teamId = team
  }
  # Otherwise, throw an error.
  else {
    message <- paste("Please pass a team id (integer) or a full team name",
                     "e.g. 'Boston Bruins'.")
    stop(message)
  }
  
  # Set the base url, endpoint, and combine them with teamId for the full url.
  baseURL <- "https://records.nhl.com/site/api/"
  endpoint <- "franchise-season-records?cayenneExp=franchiseId="
  fullURL <- paste0(baseURL, endpoint, teamId)
  
  # Get the API output.
  outputAPI <- fromJSON(fullURL)
  # Select only the data.
  output <- outputAPI$data
  
  # Convert any columns that should be numeric to numeric.
  output <- suppressMessages(as.data.frame(lapply(output, convertToNumeric)))
  
  # Return the output from the request.
  return(output)
}
```

## `goalieRecords`

The `goalieRecords` function returns the stats for all the goalies who've played for a single team. For example, the most saves in a game and the date of the game. It takes one argument; `team`, which can either be the full name of a team (e.g. `"New Jersey Devils"`), or the **franchise Id** (e.g. `23` for the New Jersey Devils).

```{r}
goalieRecords <- function(team){
  ###
  # This functions returns a dataframe with the goalie records for a team.
  ###
  
  # If team is a "character" type, try to look up the team id.
  if (typeof(team) == "character"){
    teamId = findFranchiseId(team)
  }
  # If team is an integer, set teamId equal to team.
  else if ((typeof(team) == "double") & (team %% 1 == 0)){
    teamId = team
  }
  # Otherwise, throw an error.
  else {
    message <- paste("Please pass a team id (integer) or a full team name",
                     "e.g. 'Boston Bruins'.")
    stop(message)
  }
  
  # Set the base url, endpoint, and combine them with teamId for the full url.
  baseURL <- "https://records.nhl.com/site/api/"
  endpoint <- "franchise-goalie-records?cayenneExp=franchiseId="
  fullURL <- paste0(baseURL, endpoint, teamId)
  
  # Get the API output.
  outputAPI <- fromJSON(fullURL)
  # Select only the data.
  output <- outputAPI$data
  
  # Convert any columns that should be numeric to numeric.
  output <- suppressMessages(as.data.frame(lapply(output, convertToNumeric)))
  
  # Return the output from the request.
  return(output)
}
```

## `skaterRecords`

The `skaterRecords` function returns the stats for all the non-goalie players who've played for a single team. For example, the most penalty minutes they received in one season and the season the season it occurred in. It takes one argument; `team`, which can either be the full name of a team (e.g. `"New Jersey Devils"`), or the **franchise Id** (e.g. `23` for the New Jersey Devils).

```{r}
skaterRecords <- function(team){
  ###
  # This functions returns a dataframe with the skater records for a team.
  ###
  
  # If team is a "character" type, try to look up the team id.
  if (typeof(team) == "character"){
    teamId = findFranchiseId(team)
  }
  # If team is an integer, set teamId equal to team.
  else if ((typeof(team) == "double") & (team %% 1 == 0)){
    teamId = team
  }
  # Otherwise, throw an error.
  else {
    message <- paste("Please pass a team id (integer) or a full team name",
                     "e.g. 'Boston Bruins'.")
    stop(message)
  }
  
  # Set the base url, endpoint, and combine them with teamId for the full url.
  baseURL <- "https://records.nhl.com/site/api/"
  endpoint <- "franchise-skater-records?cayenneExp=franchiseId="
  fullURL <- paste0(baseURL, endpoint, teamId)
  
  # Get the API output.
  outputAPI <- fromJSON(fullURL)
  # Select only the data.
  output <- outputAPI$data
  
  # Convert any columns that should be numeric to numeric.
  output <- suppressMessages(as.data.frame(lapply(output, convertToNumeric)))
  
  # Return the output from the request.
  return(output)
}
```

## `franchiseDetail`

This function gets info for a franchise, like their retired numbers. It takes one argument; `team`, which can either be the full name of a team (e.g. `"New Jersey Devils"`), or the most recent team Id (e.g. `1` for the New Jersey Devils).

```{r}
franchiseDetail <- function(team){
  ###
  # This functions returns a dataframe with the data for a team.
  ###
  
  # If team is a "character" type, try to look up the team id.
  if (typeof(team) == "character"){
    teamId = findTeamId(team)
  }
  # If team is an integer, set teamId equal to team.
  else if ((typeof(team) == "double") & (team %% 1 == 0)){
    teamId = team
  }
  # Otherwise, throw an error.
  else {
    message <- paste("Please pass a team id (integer) or a full team name",
                     "e.g. 'Boston Bruins'.")
    stop(message)
  }
  
  # Set the base url, endpoint, and combine them with teamId for the full url.
  baseURL <- "https://records.nhl.com/site/api/"
  endpoint <- "franchise-detail?cayenneExp=mostRecentTeamId="
  fullURL <- paste0(baseURL, endpoint, teamId)
  
  # Get the API output.
  outputAPI <- fromJSON(fullURL)
  # Select only the data.
  output <- outputAPI$data
  
  # Convert any columns that should be numeric to numeric.
  output <- suppressMessages(as.data.frame(lapply(output, convertToNumeric)))
  
  # Return the output from the request.
  return(output)
}
```

## `seasonStats`

I wrote this function to interact with the `franchise` endpoint of the [NHL Stats API](https://gitlab.com/dword4/nhlapi/-/blob/master/stats-api.md). It returns a `data.frame` containing the current season stats. It takes one argument; `team`, which can either be `"all"`, the full name of a team (e.g. `"New Jersey Devils"`), or the most recent team Id (e.g. `1` for the New Jersey Devils).

```{r}
seasonStats <- function(team="all", raw=FALSE){
  ###
  # Returns the current seasons stats for all teams or just one. If raw is 
  # FALSE, it returns only the stats. If raw is TRUE, it just returns the API
  # output for the user to parse.
  ###
  
  # If raw is not a valid input, throw an error.
  if ((raw != TRUE) & (raw != FALSE)){
    stop("raw must equal TRUE or FALSE!")
  }
  # Otherwise do nothing.
  else {
    
  }
  
  # If team equals "all" the spot where ID goes in the URL will be blank.
  if (team == "all"){
    teamId = ""
  }
  # If team is a "character" type, try to look up the team id.
  else if (typeof(team) == "character"){
    teamId = findTeamId(team)
  }
  # If team is an integer, set teamId equal to team.
  else if ((typeof(team) == "double") & (team %% 1 == 0)){
    teamId = team
  }
  # Otherwise, throw an error.
  else {
    message <- paste("Please pass a team id (integer) or a full team name",
                     "e.g. 'Boston Bruins'.")
    stop(message)
  }
  
  # Paste together the URL.
  baseURL <- "https://statsapi.web.nhl.com/api/v1/teams/"
  modifier <- "?expand=team.stats"
  fullURL <- paste0(baseURL, teamId, modifier)
  # Get the data from the endpoint.
  outputAPI <- fromJSON(fullURL, flatten=TRUE)
  
  if (team != "all"){
    
    # If raw is FALSE, give back only the stats.
    if (raw == FALSE){
      teamStats <- outputAPI$teams$teamStats[[1]]$splits[[1]][1,]
      # Convert any columns that should be numeric to numeric.
      teamStats <- suppressMessages(as.data.frame(lapply(teamStats,
                                                         convertToNumeric)))
    }
    # If the user wants the raw API output, give it to them.
    else {
      teamStats <- outputAPI$teams
    }
  }
  else {
    
    # If raw is FALSE, give back only the stats.
    if (raw == FALSE){
      # Get the teamStats list where each element is a data.frame.
      output <- outputAPI$teams$teamStats
      # Count the number of teams. The last element is NULL.
      num_teams = length(output) - 1
      # Make a variable to hold just the stats, starting with the first team.
      teamStats <- output[[1]]$splits[[1]][1,]
      
      # Loop through the 2nd to the last team in the list.
      for (i in seq(2, num_teams)){
        # Select only the first row of the seasons stats for the team.
        stats <- output[[i]]$splits[[1]][1,]
        # Add the row to teamStats.
        teamStats <- rbind(teamStats, stats)
      }
    # Convert any columns that should be numeric to numeric.
    teamStats <- suppressMessages(as.data.frame(lapply(teamStats,
                                                       convertToNumeric)))
    }
    # If the user wants the raw API output, give it to them.
    else {
      teamStats <- outputAPI$teams
    }
  }
  
  # Return team stats.
  return(teamStats)
}
```

## `nhlAPI`

This function is a wrapper function for all the others above. You simply pass the name of the function you want to use, like `"seasonStats`, and any additional arguments for that function.

```{r}
nhlAPI <- function(func, ...){
  ###
  # This function is a wrapper for the other functions. It takes in the name
  # of the function to use as a character and any additional arguments for that
  # function.
  ###
  
  # Find and call the appropriate function.
  
  if (func == "franchise"){
    output <- franchise(...)
  }
  else if (func == "teamTotals"){
    output <- teamTotals(...)
  }
  else if (func == "seasonRecords"){
    output <- seasonRecords(...)
  }
  else if (func == "goalieRecords"){
    output <- goalieRecords(...)
  }
  else if (func == "skaterRecords"){
    output <- skaterRecords(...)
  }
  else if (func == "franchiseDetail"){
    output <- franchiseDetail(...)
  }
  else if (func == "seasonStats"){
    output <- seasonStats(...)
  }
  else {
    stop("Argument for func is not valid!")
  }
  return(output)
}
```

# Data Exploration

Now that we can interact with a few of the endpoints of the NHL API, let's get some data from them.

First, let's pull current season stats for all teams by calling `nhlAPI("seasonStats")`.

```{r }
# Get the current season stats for all of the teams in the NHL.
currentSeason <- nhlAPI("seasonStats")
```

Two variables of interest to me are shots per game and shooting percentage. I'm interested in how these two stats relate to a team's win percentage. This variable doesn't exist, so I need to calculate it. The formula is $\text{Win Percentage} = \frac{\text{Wins}}{\text{Games Played}}$. 

```{r}
# Add a column for the win percentage.
currentSeason <- currentSeason %>%
  mutate(win.percentage = stat.wins / stat.gamesPlayed)
```

My guess is these two are positively related to the win percentage. A high shooting percentage means you are fairly likely to score when you shoot. A high number of shots per game likely means you are controlling the puck more than the other team and you have more scoring opportunities, unless you're taking wild shots. Plus, I think there is a quote from some hockey player about taking shots.

```{r}
# Read in the image.
img <- load.image("./images/Wayne Gretzky Quote.jpg")
# Display the image.
plot(img, axes=0)
```

Below I plotted the win percentage against shots per game and shooting percentage. I added a regression line as well. As expected, both are positively related to the win percentage, although there appears to be some [heteroskedasticity](https://en.wikipedia.org/wiki/Heteroscedasticity) in the plot on the right.

```{r}
# Create a scatter plot of win pct vs. shots per game.
plot1 <- ggplot(currentSeason, aes(stat.shotsPerGame,
                                   win.percentage,
                                   color=win.percentage)) + 
  geom_point(size=4, alpha=0.75) + 
  scale_color_gradient(low="blue", high="red") + 
  theme(legend.position="none") + 
  geom_smooth(method=lm, formula=y~x, color="black") + 
  scale_x_continuous("Shots per Game") + 
  scale_y_continuous("Win Percentage") + 
  ggtitle("Win Pct. vs. Shots per Game")

# Create a scatter plot of win pct vs. shooting pct.
plot2 <- ggplot(currentSeason, aes(stat.shootingPctg,
                                   win.percentage,
                                   color=win.percentage)) + 
  geom_point(size=4, alpha=0.75) + 
  scale_color_gradient(low="blue", high="red") + 
  theme(legend.position="none") + 
  geom_smooth(method=lm, formula=y~x, color="black") + 
  scale_x_continuous("Shooting Percentage") + 
  scale_y_continuous("Win Percentage") + 
  ggtitle("Win Pct. vs. Shooting Pct.")

# Plot them both together.
plot_grid(plot1, plot2, ncol=2)
```

Now let's look at shooting percentage vs. shots per game. I added a color gradient for the win percentage. 

```{r}
# Create a scatter plot of shooting pct vs. shots per game.
plot3 <- ggplot(currentSeason, aes(stat.shotsPerGame,
                                   stat.shootingPctg,
                                   color=win.percentage)) + 
  geom_point(size=4, alpha=0.75) + 
  scale_color_gradient(low="blue", high="red", name="Win Pct.") + 
  scale_x_continuous("Shots per Game") + 
  scale_y_continuous("Shooting Percentage") + 
  ggtitle("Shooting Pct. vs. Shots per Game") 

# Show the plot.
plot3
```

There doesn't appear to be a clear relationship between those two variables.

Now let's look at some stats for the total history of all teams. I called `nhlAPI("teamTotals")` to get this data.

```{r}
# Get some stats for the total history of a team.
teamTotalStats <- nhlAPI("teamTotals")
```

First, let's compare the number of inactive vs. active teams.

```{r}
teamStatus <- teamTotalStats %>%
  # Filter for regular season stats.
  filter(gameTypeId == 2) %>%
  # Create a column that tells whether a team is active or not.
  mutate(currentlyActive = ifelse(is.na(lastSeasonId), 
                                  "Active", "Inactive")) %>%
  # Select the teamName and activity status columns.
  select(teamName, currentlyActive)

# Count the number of active and inactive teams.
numActive <- sum(teamStatus =="Active")
numInactive <- sum(teamStatus =="Inactive")
```

There are `r print(numInactive)` inactive and `r print(numActive)` active teams. Almost as many teams have left the NHL than are currently still playing.

Not all the teams have been around for the same length of time and I want to adjust some stats, say total penalty minutes, to be able to compare teams on the same basis. 

To do this, I'm calculating the the penalty minutes per game as $\frac{\text{Total Penalty Minutes}}{\text{Total Games Played}}$. I again calculate the win percentage as $\text{Win Percentage} = \frac{\text{Wins}}{\text{Games Played}}$, because I want to see how penalty minutes relate to a team's record. I'm also interested in how a game being a playoff or regular season game affects penalty minutes because I think the importance of a playoff game might cause changes in the penalty behavior.

I also created a column, `recordType` that indicates if a team has a winning or losing record. They are classified as having a winning record if $0.5 < \frac{\text{Wins}}{\text{Games Played}}$ and a losing record if $0.5 \geq \frac{\text{Wins}}{\text{Games Played}}$.

```{r}
teamTotalStats <- teamTotalStats %>%
  # Calculate the penalty minutes per game, win percentage, a text
  # representation of the game type, and whether a team has a losing or winning
  # record for the game type.
  mutate(penaltyMinutesPerGame = penaltyMinutes / gamesPlayed,
         winPercentage = wins / gamesPlayed,
         gameType = ifelse(gameTypeId == 2, "Regular Season", "Playoffs"),
         recordType = ifelse(wins > losses, "Winning Record", "Losing Record"))
```

Below is a table showing the count of active teams with losing and winning records by game type. 

```{r}
# Filter for active teams.
activeTeams <- teamTotalStats %>%
  filter((is.na(lastSeasonId) == TRUE))

# Display a table of the game types by record types for active teams.
knitr::kable(table(activeTeams$gameType, activeTeams$recordType),
             caption=paste("Counts of Franchise Record Types by Game Type",
                           "for Active Franchises"))
```

Below is the table showing for inactive teams. It's clear from these tables that the inactive teams were much worse than the teams that are still active. They probably had a difficult time bringing in an audience and selling merchandise because they were so bad. That is likely why they are no longer around. 

```{r}
# Filter for only inactive teams.
inactiveTeams <- teamTotalStats %>%
  filter((is.na(lastSeasonId) == FALSE))
# Count the number of inactive teams using the number of teams with regular
# season games.
numInactiveTeams <- dim(filter(inactiveTeams, gameTypeId == 2))[1]
# Count the number of inactive teams that made it to the playoffs, which is not
# all of them.
numInactiveTeamsInPlayoffs <- dim(filter(inactiveTeams, gameTypeId == 3))[1]
# Count the number of inactive teams who did not make the playoffs.
numDidntMakePlayoffs <- numInactiveTeams - numInactiveTeamsInPlayoffs
# Create an index for the last row in inactive teams.
currentEndRow <- nrow(inactiveTeams)
# Add as many empty rows to inactiveTeams as teams not making the playoffs.
inactiveTeams[currentEndRow+seq(numDidntMakePlayoffs),] <- NA
# Teams without playoff data do not have rows for that game type. I'm going to
# classify them as having losing records in the playoffs.
inactiveTeams[currentEndRow+seq(numDidntMakePlayoffs), 
              "recordType"] <- "Losing Record"
# To make the table work, I need to make the gameType of these rows "Playoffs".
inactiveTeams[currentEndRow+seq(numDidntMakePlayoffs), 
              "gameType"] <- "Playoffs"

# Display a table of the game types by record types for inactive teams.
knitr::kable(table(inactiveTeams$gameType, inactiveTeams$recordType),
             caption=paste("Counts of Franchise Record Types by Game Type",
                           "for Inactive Franchises"))
```

Going forward, I will look at all teams, regardless of whether they are active or inactive. 

No let's get a numerical summary of the win percentage by the game type.

```{r}
winPercSumm <- teamTotalStats %>% 
  # Select the gameType and winPercentage columns.
  select(gameType, winPercentage) %>%
  # Group by game type.
  group_by(gameType) %>%
  # Get summary statistics for winPercentage.
  summarize("Min." = min(winPercentage),
            "1st Quartile" = quantile(winPercentage, 0.25, na.rm=TRUE),
            "Median" = quantile(winPercentage, 0.5, na.rm=TRUE),
            "Mean" = mean(winPercentage, na.rm=TRUE),
            "3rd Quartile" = quantile(winPercentage, 0.75, na.rm=TRUE),
            "Max" = max(winPercentage),
            "Std. Dev." = sd(winPercentage, na.rm=TRUE)
            )

# Display a table of the summary stats.
knitr::kable(winPercSumm, 
             caption="Summary Statistics for win percentage by game type",
             digits=2)
```

Based on the summary stats, the distributions don't seem very different, although win percentages in the playoffs might be more variable. There is at least on franchise that never won a playoff game. Let's visualize the distributions with a box plot.

```{r}
# Make a plot of franchise win percentage by game type.
plot4 <- ggplot(teamTotalStats, 
               aes(gameType,
                   winPercentage,
                   color=gameType)) + geom_boxplot() + 
  geom_jitter() + 
  scale_x_discrete("Game Type") + 
  scale_y_continuous("Win Percentage") +
  ggtitle("Franchise Win Percentage by Game Type") + 
  theme(legend.position="none")

# Display the plot.
plot4
```

Now let's look at a numeric summary of per game penalty minutes by game type. Playoff games seem to have a higher central tendency and be more variable in the penalty minutes per game.

```{r}
penMinSumm <- teamTotalStats %>% 
  # Select the gameType and penaltyMinutesPerGame columns.
  select(gameType, penaltyMinutesPerGame) %>%
  # Group by game type.
  group_by(gameType) %>%
  # Get summary statistics for penaltyMinutesPerGame.
  summarize("Min." = min(penaltyMinutesPerGame),
            "1st Quartile" = quantile(penaltyMinutesPerGame, 0.25),
            "Median" = quantile(penaltyMinutesPerGame, 0.5),
            "Mean" = mean(penaltyMinutesPerGame),
            "3rd Quartile" = quantile(penaltyMinutesPerGame, 0.75),
            "Max" = max(penaltyMinutesPerGame),
            "Std. Dev." = sd(penaltyMinutesPerGame)
            )

# Display a table of the summary stats.
knitr::kable(penMinSumm, 
             caption=paste("Summary Statistics for Penalty Minutes per",
                           "Game by Game Type"),
             digits=2)
```

The histogram below provides an alternative to the box plot for visualizing the distribution of a penalty minutes per game. It's clear the penalty minutes per playoff game has a right tail stretching beyond regular season games.

```{r}
# Make a histogram of penalty minutes per game by game type.
plot5 <- ggplot(teamTotalStats,aes(penaltyMinutesPerGame, y=..density..,
                                   fill=gameType)) + 
    geom_histogram(data=subset(teamTotalStats,gameType == 'Regular Season'),
                   bins=10, alpha = 0.5) +
    geom_histogram(data=subset(teamTotalStats,gameType == 'Playoffs'),
                   bins=10, alpha = 0.5) + 
  guides(fill=guide_legend(title="Game Type")) +
  scale_x_continuous("Penalty Minutes per Game") + 
  scale_y_continuous("Density") +
  ggtitle("Histogram of Penalty Minutes per Game by Game Type")

# Display the plot.
plot5
```

I'm curious as to which teams spend the most time in the penalty box per game. I filtered for active teams and regular season games and made a bar chart for each team and their penalty minutes per game. I sorted the bars in the bar chart from worst behaved to best behaved.

```{r}
# Create a column with the triCode for each team ordered by most penalty 
# time per game to least.
mostPenaltyMinsRegSeason <- teamTotalStats %>%
  # Filter for active teams and regular season games.
  filter(is.na(lastSeasonId) & (gameTypeId == 2)) %>%
  # Sort from most penalty minutes per game to the least.
  arrange(desc(penaltyMinutesPerGame)) %>%
  # select the triCode column.
  select(triCode)

# Create a bar chart for the penalty mins per regular season game by active 
# teams.
plot6 <- teamTotalStats %>%
  # Filter for active teams and their regular season stats.
  filter(is.na(lastSeasonId) & (gameTypeId == 2)) %>%
  # Create a column that is a sorted factor of triCode.
  mutate(sortedTriCode = factor(triCode,
                                levels=mostPenaltyMinsRegSeason[["triCode"]],
                                ordered=TRUE))  %>%
  # Create a bar chart.
  ggplot(aes(sortedTriCode, penaltyMinutesPerGame, 
             fill=penaltyMinutesPerGame)) +
  geom_col() + 
  theme(axis.text.x=element_text(angle=90), legend.position="none") +
  scale_fill_gradient(low="blue", high="red") +
  scale_x_discrete("Team") + 
  scale_y_continuous("Penalty Minutes per Game") +
  ggtitle("Penalty Minutes per Regular Season Game by Team")

# Display the plot.
plot6
```

It seems the Philly Fliers are as rowdy as Philly sports fans. I produced the same bar plot again, but this time for playoff games. I kept the ordering of most rowdy in the regular season. If there is a correlation between penalties in the regular season and in the playoffs, we will expect the order to not change much.

```{r}
# Create a bar chart for the penalty mins per playoff game by active 
# teams.
plot7 <- teamTotalStats %>%
  # Filter for active teams and their playoff stats.
  filter(is.na(lastSeasonId) & (gameTypeId == 3)) %>%
  # Create a column that is a sorted factor of triCode.
  mutate(sortedTriCode = factor(triCode,
                                levels=mostPenaltyMinsRegSeason[["triCode"]],
                                ordered=TRUE))  %>%
  # Create a bar chart.
  ggplot(aes(sortedTriCode, penaltyMinutesPerGame, 
             fill=penaltyMinutesPerGame)) +
  geom_col() + 
  theme(axis.text.x=element_text(angle=90), legend.position="none") +
  scale_fill_gradient(low="blue", high="red") +
  scale_x_discrete("Team") + 
  scale_y_continuous("Penalty Minutes per Game") +
  ggtitle("Penalty Minutes per Playoff Game by Team")

# Display the plot.
plot7
```

The order did not change much, so there is a correlation between regular season penalty time and playoff penalty time. Let's look at a scatter plot between penalty minutes per game in the playoffs vs. the regular season.

```{r}
# Create a scatter plot of playoff penalty time per game vs. regular season.
plot8 <- teamTotalStats %>%
  # Filter for active teams.
  filter(is.na(lastSeasonId)) %>%
  # Select triCode, gameType, and penaltyMinutesPer Game.
  select(triCode, gameType, penaltyMinutesPerGame) %>%
  # Spread penaltyMinutesPerGame by gameType.
  spread(gameType, penaltyMinutesPerGame) %>%
  # Create a scatter plot with a regression line.
  ggplot(aes(`Regular Season`, Playoffs)) +
  geom_point(alpha=0.75,  color="blue") + 
  geom_smooth(method=lm, formula=y~x, color="red") +
  scale_x_continuous("Regular Penalty Min. per Game") +
  scale_y_continuous("Playoffs Penalty Min. per Game") + 
  ggtitle("Playoff vs. Regular Season Penalty Min. Per Game (Active Teams)")

plot8
```

Although the positive correlation is not very surprising, I did not expect the correlation to be that tight.

I wonder how penalty minutes per game relates to the win percentage. Let's find out!

I created a scatter plot for the win percentage vs the penalty minutes per game by game type. I experimented with the regression lines a little. I first started with a [LOESS](https://en.wikipedia.org/wiki/Local_regression) regression line and saw an upside-down U pattern to the lines. I decided to plot them with a quadratic regression line to make things smoother.

```{r}
plot9 <- teamTotalStats %>%
  mutate(sortedTriCode  = factor(triCode,
                                 levels=mostPenaltyMinsRegSeason[["triCode"]],
                                    ordered=TRUE)) %>%
  select(sortedTriCode, gameType, penaltyMinutesPerGame, winPercentage) %>%
  ggplot(aes(penaltyMinutesPerGame, winPercentage, color=gameType)) +
  geom_point(size=2) + geom_smooth(method="lm", formula="y~poly(x, 2)") + 
  scale_x_continuous("Penalty Minutes per Game") + 
  scale_y_continuous("Win Percentage") + 
  theme(legend.position = "none") + 
  ggtitle("Win Percentage vs. Penalty Minutes per Game by Game Type") + 
  facet_wrap(~gameType)

plot9
```

As you can see, the relationship between the win percentage and penalty minutes per game is not exactly tidy, but there does seem to be a quadratic relationship there. In regular season games, it seems like 15 minutes is an optimal amount of time to be in the penalty box with regards to the win percentage. For playoff games, it appears to be in the ballpark of 17 minutes.

I do not know much about hockey, but it seems like there is a strategy to taking penalties, even if it gives the other team a power play opportunity.

```{r}
# Create a model regressing win percentage on game type and penalty minutes
# per game for playoff games.
winPercMod <- lm(winPercentage ~ poly(penaltyMinutesPerGame, 2),
                 data=teamTotalStats)

# Get the percentage of variance explained.
playoffVarExplainedPerc <- round(100*summary(winPercMod)[[8]],1)

# Create a table of the regression coefficients.
winPercMod %>%
  tidy() %>%
  knitr::kable(
    caption=paste("Coefficient summary of Win Perc. regressed on",
                  "Penalty Min. per Game for Playoff Games"),
    col.names = c("Predictor", "Est. Coef.", "SE", "t", "P(|t| > 0)"),
    digits=c(0, 2, 3, 2, 3)
  )
```

Given the t-statistics for the regression coefficients, a quadratic relationship appears reasonable. This model explains `r print(paste0(playoffVarExplained, "%")` of the variation in win percentage.
